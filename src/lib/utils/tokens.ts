import type { BrandKit, ColorPalette, DesignTokens, Typography } from '../types/brand';

// Generate W3C DTCG compliant design tokens
export function generateDesignTokens(
  colors: ColorPalette,
  typography: Typography
): DesignTokens {
  const colorTokens: DesignTokens['color'] = {};
  const typographyTokens: DesignTokens['typography'] = {};

  // Add primary colors
  colors.primary.forEach((color, index) => {
    const key = index === 0 ? 'primary' : `primary-${index + 1}`;
    colorTokens[key] = {
      $type: 'color',
      $value: {
        colorSpace: 'srgb',
        hex: color.hex,
      },
      $description: color.usage || `Primary brand color ${index + 1}`,
    };
  });

  // Add secondary colors
  colors.secondary.forEach((color, index) => {
    colorTokens[`secondary-${index + 1}`] = {
      $type: 'color',
      $value: {
        colorSpace: 'srgb',
        hex: color.hex,
      },
      $description: color.usage || `Secondary color ${index + 1}`,
    };
  });

  // Add accent colors
  colors.accent.forEach((color, index) => {
    colorTokens[`accent${index > 0 ? `-${index + 1}` : ''}`] = {
      $type: 'color',
      $value: {
        colorSpace: 'srgb',
        hex: color.hex,
      },
      $description: color.usage || 'Accent color for highlights',
    };
  });

  // Add neutral colors
  colors.neutral.forEach((color, index) => {
    const step = (10 - index) * 100;
    colorTokens[`neutral-${step}`] = {
      $type: 'color',
      $value: {
        colorSpace: 'srgb',
        hex: color.hex,
      },
    };
  });

  // Add semantic colors
  colorTokens['success'] = {
    $type: 'color',
    $value: { colorSpace: 'srgb', hex: colors.semantic.success.hex },
    $description: 'Success state color',
  };
  colorTokens['error'] = {
    $type: 'color',
    $value: { colorSpace: 'srgb', hex: colors.semantic.error.hex },
    $description: 'Error state color',
  };
  colorTokens['warning'] = {
    $type: 'color',
    $value: { colorSpace: 'srgb', hex: colors.semantic.warning.hex },
    $description: 'Warning state color',
  };
  colorTokens['info'] = {
    $type: 'color',
    $value: { colorSpace: 'srgb', hex: colors.semantic.info.hex },
    $description: 'Info state color',
  };

  // Add typography tokens
  typography.scale.sizes.forEach(size => {
    typographyTokens[size.name] = {
      $type: 'typography',
      $value: {
        fontFamily: size.name.includes('xl') || size.name === 'lg'
          ? typography.headingFont.family
          : typography.bodyFont.family,
        fontSize: `${size.size}px`,
        fontWeight: size.name.includes('xl') ? '700' : '400',
        lineHeight: String(size.lineHeight),
        letterSpacing: size.letterSpacing ? `${size.letterSpacing}em` : undefined,
      },
    };
  });

  // Add spacing tokens (standard scale)
  const spacingTokens: DesignTokens['spacing'] = {};
  [0, 1, 2, 3, 4, 5, 6, 8, 10, 12, 16, 20, 24, 32, 40, 48, 64].forEach(value => {
    spacingTokens[String(value)] = {
      $type: 'dimension',
      $value: {
        value: value * 4,
        unit: 'px',
      },
    };
  });

  return {
    color: colorTokens,
    typography: typographyTokens,
    spacing: spacingTokens,
  };
}

// Generate CSS variables from design tokens
export function generateCSSVariables(tokens: DesignTokens): string {
  const lines: string[] = [':root {'];

  // Color variables
  lines.push('  /* Colors */');
  for (const [key, value] of Object.entries(tokens.color)) {
    lines.push(`  --color-${key}: ${value.$value.hex};`);
  }

  lines.push('');
  lines.push('  /* Typography */');
  for (const [key, value] of Object.entries(tokens.typography)) {
    lines.push(`  --font-size-${key}: ${value.$value.fontSize};`);
    lines.push(`  --line-height-${key}: ${value.$value.lineHeight};`);
  }

  lines.push('');
  lines.push('  /* Spacing */');
  for (const [key, value] of Object.entries(tokens.spacing)) {
    lines.push(`  --spacing-${key}: ${value.$value.value}${value.$value.unit};`);
  }

  lines.push('}');

  return lines.join('\n');
}

// Generate SCSS variables
export function generateSCSSVariables(tokens: DesignTokens): string {
  const lines: string[] = ['// Design Tokens - Generated by Brand Kit Generator', ''];

  lines.push('// Colors');
  for (const [key, value] of Object.entries(tokens.color)) {
    lines.push(`$color-${key}: ${value.$value.hex};`);
  }

  lines.push('');
  lines.push('// Typography');
  for (const [key, value] of Object.entries(tokens.typography)) {
    lines.push(`$font-size-${key}: ${value.$value.fontSize};`);
    lines.push(`$line-height-${key}: ${value.$value.lineHeight};`);
  }

  lines.push('');
  lines.push('// Spacing');
  for (const [key, value] of Object.entries(tokens.spacing)) {
    lines.push(`$spacing-${key}: ${value.$value.value}${value.$value.unit};`);
  }

  return lines.join('\n');
}

// Generate Tailwind CSS config extension
export function generateTailwindConfig(tokens: DesignTokens, typography: Typography): string {
  const colors: Record<string, string> = {};
  const spacing: Record<string, string> = {};

  for (const [key, value] of Object.entries(tokens.color)) {
    colors[key] = value.$value.hex;
  }

  for (const [key, value] of Object.entries(tokens.spacing)) {
    spacing[key] = `${value.$value.value}${value.$value.unit}`;
  }

  const config = {
    theme: {
      extend: {
        colors: {
          brand: colors,
        },
        fontFamily: {
          heading: [typography.headingFont.family, typography.headingFont.category],
          body: [typography.bodyFont.family, typography.bodyFont.category],
        },
        spacing,
      },
    },
  };

  return `// Tailwind CSS Configuration Extension
// Add this to your tailwind.config.js

module.exports = ${JSON.stringify(config, null, 2)}`;
}

// Generate full tokens JSON file
export function generateTokensJSON(brandKit: BrandKit): string {
  const tokenStructure = {
    $schema: 'https://design-tokens.github.io/community-group/format/',
    name: brandKit.name,
    description: `Design tokens for ${brandKit.name} brand`,
    version: '1.0.0',
    ...brandKit.tokens,
  };

  return JSON.stringify(tokenStructure, null, 2);
}
