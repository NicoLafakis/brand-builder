import type { BrandKit, ColorPalette, DesignTokens, Typography } from '../types/brand';

// Generate W3C DTCG compliant design tokens
export function generateDesignTokens(
  colors: ColorPalette,
  typography: Typography
): DesignTokens {
  const colorTokens: DesignTokens['color'] = {};
  const typographyTokens: DesignTokens['typography'] = {};

  // Add 3-Tier Colors
  const tiers = ['primary', 'secondary', 'accent'] as const;
  tiers.forEach(tier => {
    const scale = colors[tier];
    const shades = [50, 100, 200, 300, 400, 500, 600, 700, 800, 900, 950] as const;
    shades.forEach(shade => {
      colorTokens[`${tier}-${shade}`] = {
        $type: 'color',
        $value: { colorSpace: 'srgb', hex: scale[shade].hex },
      };
    });
    // Add base alias
    colorTokens[tier] = {
      $type: 'color',
      $value: { colorSpace: 'srgb', hex: scale[500].hex },
      $description: `Base ${tier} color`,
    };
  });

  // Add Neutral
  colors.neutral.forEach((color, index) => {
    const step = (10 - index) * 100;
    colorTokens[`neutral-${step}`] = {
      $type: 'color',
      $value: { colorSpace: 'srgb', hex: color.hex },
    };
  });

  // Add Semantic
  Object.entries(colors.semantic).forEach(([key, color]) => {
    colorTokens[key] = {
      $type: 'color',
      $value: { colorSpace: 'srgb', hex: color.hex },
    };
  });

  // Add Typography Hierarchy
  Object.entries(typography.hierarchy).forEach(([tag, style]) => {
    typographyTokens[tag] = {
      $type: 'typography',
      $value: {
        fontFamily: style.fontFamily,
        fontSize: style.fontSize,
        fontWeight: style.fontWeight,
        lineHeight: style.lineHeight,
        letterSpacing: style.letterSpacing,
      },
    };
  });

  // Add Body Variants
  Object.entries(typography.bodyVariants).forEach(([name, style]) => {
    typographyTokens[`body-${name}`] = {
      $type: 'typography',
      $value: {
        fontFamily: style.fontFamily,
        fontSize: style.fontSize,
        fontWeight: style.fontWeight,
        lineHeight: style.lineHeight,
      },
    };
  });

  // Add spacing tokens (standard scale)
  const spacingTokens: DesignTokens['spacing'] = {};
  [0, 1, 2, 3, 4, 5, 6, 8, 10, 12, 16, 20, 24, 32, 40, 48, 64].forEach(value => {
    spacingTokens[String(value)] = {
      $type: 'dimension',
      $value: {
        value: value * 4,
        unit: 'px',
      },
    };
  });

  return {
    color: colorTokens,
    typography: typographyTokens,
    spacing: spacingTokens,
  };
}

// Generate CSS variables from design tokens
export function generateCSSVariables(tokens: DesignTokens): string {
  const lines: string[] = [':root {'];

  // Color variables
  lines.push('  /* Colors */');
  for (const [key, value] of Object.entries(tokens.color)) {
    lines.push(`  --color-${key}: ${value.$value.hex};`);
  }

  lines.push('');
  lines.push('  /* Typography */');
  for (const [key, value] of Object.entries(tokens.typography)) {
    lines.push(`  --font-size-${key}: ${value.$value.fontSize};`);
    lines.push(`  --line-height-${key}: ${value.$value.lineHeight};`);
  }

  lines.push('');
  lines.push('  /* Spacing */');
  for (const [key, value] of Object.entries(tokens.spacing)) {
    lines.push(`  --spacing-${key}: ${value.$value.value}${value.$value.unit};`);
  }

  lines.push('}');

  return lines.join('\n');
}

// Generate SCSS variables
export function generateSCSSVariables(tokens: DesignTokens): string {
  const lines: string[] = ['// Design Tokens - Generated by Brand Kit Generator', ''];

  lines.push('// Colors');
  for (const [key, value] of Object.entries(tokens.color)) {
    lines.push(`$color-${key}: ${value.$value.hex};`);
  }

  lines.push('');
  lines.push('// Typography');
  for (const [key, value] of Object.entries(tokens.typography)) {
    lines.push(`$font-size-${key}: ${value.$value.fontSize};`);
    lines.push(`$line-height-${key}: ${value.$value.lineHeight};`);
  }

  lines.push('');
  lines.push('// Spacing');
  for (const [key, value] of Object.entries(tokens.spacing)) {
    lines.push(`$spacing-${key}: ${value.$value.value}${value.$value.unit};`);
  }

  return lines.join('\n');
}

// Generate Tailwind CSS config extension
export function generateTailwindConfig(tokens: DesignTokens, typography: Typography): string {
  const colors: Record<string, string> = {};
  const spacing: Record<string, string> = {};

  for (const [key, value] of Object.entries(tokens.color)) {
    colors[key] = value.$value.hex;
  }

  for (const [key, value] of Object.entries(tokens.spacing)) {
    spacing[key] = `${value.$value.value}${value.$value.unit}`;
  }

  const config = {
    theme: {
      extend: {
        colors: {
          brand: colors,
        },
        fontFamily: {
          headlines: [typography.headlines.family, typography.headlines.category],
          subheadings: [typography.subheadings.family, typography.subheadings.category],
          body: [typography.body.family, typography.body.category],
          code: [typography.code.family, typography.code.category],
        },
        spacing,
      },
    },
  };

  return `// Tailwind CSS Configuration Extension
// Add this to your tailwind.config.js

module.exports = ${JSON.stringify(config, null, 2)}`;
}

// Generate full tokens JSON file
export function generateTokensJSON(brandKit: BrandKit): string {
  const tokenStructure = {
    $schema: 'https://design-tokens.github.io/community-group/format/',
    name: brandKit.name,
    description: `Design tokens for ${brandKit.name} brand`,
    version: '1.0.0',
    ...brandKit.tokens,
  };

  return JSON.stringify(tokenStructure, null, 2);
}
